// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package courses

import (
	"context"
)

const addCourseBasicInfo = `-- name: AddCourseBasicInfo :one
UPDATE human_resources.courses SET
        title = $1,
        subtitle = $2,
        description = $3,
        language = $4,
        level = $5,
        category_id = $6,
        updated_at = now()
                        WHERE id = $7 RETURNING id
`

type AddCourseBasicInfoParams struct {
	Title       string
	Subtitle    *string
	Description string
	Language    *string
	Level       *string
	CategoryID  *int32
	ID          int32
}

func (q *Queries) AddCourseBasicInfo(ctx context.Context, arg *AddCourseBasicInfoParams) (int32, error) {
	row := q.db.QueryRow(ctx, addCourseBasicInfo,
		arg.Title,
		arg.Subtitle,
		arg.Description,
		arg.Language,
		arg.Level,
		arg.CategoryID,
		arg.ID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addCourseGoals = `-- name: AddCourseGoals :one
UPDATE human_resources.courses SET course_goals = $1, requirements = $2, target_audience = $3, updated_at = now() WHERE id = $4 RETURNING id
`

type AddCourseGoalsParams struct {
	CourseGoals    []string
	Requirements   []string
	TargetAudience []string
	ID             int32
}

func (q *Queries) AddCourseGoals(ctx context.Context, arg *AddCourseGoalsParams) (int32, error) {
	row := q.db.QueryRow(ctx, addCourseGoals,
		arg.CourseGoals,
		arg.Requirements,
		arg.TargetAudience,
		arg.ID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const approveCourse = `-- name: ApproveCourse :one
UPDATE human_resources.courses SET status = 'READY', updated_at = now()  WHERE id = $1 RETURNING id
`

func (q *Queries) ApproveCourse(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, approveCourse, id)
	err := row.Scan(&id)
	return id, err
}

const createCourseBase = `-- name: CreateCourseBase :one
INSERT INTO human_resources.courses (
                title,
                type,
                author_id,
                category_id,
                time_planned)
VALUES ($1,
        $2,
        $3,
        $4,
        $5
       ) RETURNING id
`

type CreateCourseBaseParams struct {
	Title       string
	Type        NullHumanResourcesCourseTypes
	AuthorID    int32
	CategoryID  *int32
	TimePlanned *string
}

func (q *Queries) CreateCourseBase(ctx context.Context, arg *CreateCourseBaseParams) (int32, error) {
	row := q.db.QueryRow(ctx, createCourseBase,
		arg.Title,
		arg.Type,
		arg.AuthorID,
		arg.CategoryID,
		arg.TimePlanned,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getAllDraftCourses = `-- name: GetAllDraftCourses :many
SELECT id, author_id, title, subtitle, description, avatar_url, students_count, ratings_count, rating, category_id, subcategory_id, language, level, time_planned, course_goals, requirements, target_audience, type, status, lectures_length, lectures_count, preview_video_url, created_at, updated_at FROM human_resources.courses c
WHERE c.status != 'PENDING'
  AND c.status != 'READY'
ORDER BY
    c.created_at
`

func (q *Queries) GetAllDraftCourses(ctx context.Context) ([]*HumanResourcesCourse, error) {
	rows, err := q.db.Query(ctx, getAllDraftCourses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HumanResourcesCourse
	for rows.Next() {
		var i HumanResourcesCourse
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.Title,
			&i.Subtitle,
			&i.Description,
			&i.AvatarUrl,
			&i.StudentsCount,
			&i.RatingsCount,
			&i.Rating,
			&i.CategoryID,
			&i.SubcategoryID,
			&i.Language,
			&i.Level,
			&i.TimePlanned,
			&i.CourseGoals,
			&i.Requirements,
			&i.TargetAudience,
			&i.Type,
			&i.Status,
			&i.LecturesLength,
			&i.LecturesCount,
			&i.PreviewVideoUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPendingCourses = `-- name: GetAllPendingCourses :many
SELECT id, author_id, title, subtitle, description, avatar_url, students_count, ratings_count, rating, category_id, subcategory_id, language, level, time_planned, course_goals, requirements, target_audience, type, status, lectures_length, lectures_count, preview_video_url, created_at, updated_at  FROM human_resources.courses c
WHERE c.status != 'DRAFT'
  AND c.status != 'READY'
ORDER BY
    c.created_at
`

func (q *Queries) GetAllPendingCourses(ctx context.Context) ([]*HumanResourcesCourse, error) {
	rows, err := q.db.Query(ctx, getAllPendingCourses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HumanResourcesCourse
	for rows.Next() {
		var i HumanResourcesCourse
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.Title,
			&i.Subtitle,
			&i.Description,
			&i.AvatarUrl,
			&i.StudentsCount,
			&i.RatingsCount,
			&i.Rating,
			&i.CategoryID,
			&i.SubcategoryID,
			&i.Language,
			&i.Level,
			&i.TimePlanned,
			&i.CourseGoals,
			&i.Requirements,
			&i.TargetAudience,
			&i.Type,
			&i.Status,
			&i.LecturesLength,
			&i.LecturesCount,
			&i.PreviewVideoUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllReadyCourses = `-- name: GetAllReadyCourses :many
SELECT id, author_id, title, subtitle, description, avatar_url, students_count, ratings_count, rating, category_id, subcategory_id, language, level, time_planned, course_goals, requirements, target_audience, type, status, lectures_length, lectures_count, preview_video_url, created_at, updated_at FROM human_resources.courses c
WHERE c.status != 'DRAFT'
  AND c.status != 'PENDING'
ORDER BY
    c.created_at
`

func (q *Queries) GetAllReadyCourses(ctx context.Context) ([]*HumanResourcesCourse, error) {
	rows, err := q.db.Query(ctx, getAllReadyCourses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HumanResourcesCourse
	for rows.Next() {
		var i HumanResourcesCourse
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.Title,
			&i.Subtitle,
			&i.Description,
			&i.AvatarUrl,
			&i.StudentsCount,
			&i.RatingsCount,
			&i.Rating,
			&i.CategoryID,
			&i.SubcategoryID,
			&i.Language,
			&i.Level,
			&i.TimePlanned,
			&i.CourseGoals,
			&i.Requirements,
			&i.TargetAudience,
			&i.Type,
			&i.Status,
			&i.LecturesLength,
			&i.LecturesCount,
			&i.PreviewVideoUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCourses = `-- name: GetUserCourses :many
SELECT c.id, c.title, c.description, c.avatar_url, c.subtitle, c.rating, c.students_count, c.ratings_count, c.lectures_length FROM human_resources.courses c
                    INNER JOIN human_resources.courses_attendants uc ON c.id = uc.course_id
WHERE uc.user_id = $1
  AND c.status != 'DRAFT'
  AND c.status != 'PENDING'
ORDER BY
    c.created_at
`

type GetUserCoursesRow struct {
	ID             int32
	Title          string
	Description    string
	AvatarUrl      *string
	Subtitle       *string
	Rating         *float64
	StudentsCount  *int32
	RatingsCount   *int32
	LecturesLength *int32
}

func (q *Queries) GetUserCourses(ctx context.Context, userID int32) ([]*GetUserCoursesRow, error) {
	rows, err := q.db.Query(ctx, getUserCourses, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUserCoursesRow
	for rows.Next() {
		var i GetUserCoursesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.AvatarUrl,
			&i.Subtitle,
			&i.Rating,
			&i.StudentsCount,
			&i.RatingsCount,
			&i.LecturesLength,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertLectureAndCourseLecture = `-- name: InsertLectureAndCourseLecture :one
WITH inserted_lecture AS (
    INSERT INTO human_resources.lectures (video_url)
        VALUES ($2)
        RETURNING id
)
INSERT INTO human_resources.courses_lectures (course_id, lecture_id)
VALUES ($1, (SELECT id FROM inserted_lecture))
RETURNING id, course_id, lecture_id
`

type InsertLectureAndCourseLectureParams struct {
	CourseID int32
	VideoUrl string
}

type InsertLectureAndCourseLectureRow struct {
	ID        int32
	CourseID  int32
	LectureID int32
}

// Вставляет лекцию в таблицу lectures и соответствующую запись в таблицу courses_lectures
func (q *Queries) InsertLectureAndCourseLecture(ctx context.Context, arg *InsertLectureAndCourseLectureParams) (*InsertLectureAndCourseLectureRow, error) {
	row := q.db.QueryRow(ctx, insertLectureAndCourseLecture, arg.CourseID, arg.VideoUrl)
	var i InsertLectureAndCourseLectureRow
	err := row.Scan(&i.ID, &i.CourseID, &i.LectureID)
	return &i, err
}

const insertLectureTitleAndDescription = `-- name: InsertLectureTitleAndDescription :one
UPDATE human_resources.lectures SET title = $1, description = $2 WHERE id = $3 RETURNING id
`

type InsertLectureTitleAndDescriptionParams struct {
	Title       string
	Description string
	ID          int32
}

func (q *Queries) InsertLectureTitleAndDescription(ctx context.Context, arg *InsertLectureTitleAndDescriptionParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertLectureTitleAndDescription, arg.Title, arg.Description, arg.ID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const rejectCourse = `-- name: RejectCourse :one
UPDATE human_resources.courses SET status = 'DRAFT', updated_at = now()  WHERE id = $1 RETURNING id
`

func (q *Queries) RejectCourse(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, rejectCourse, id)
	err := row.Scan(&id)
	return id, err
}

const removeLecture = `-- name: RemoveLecture :one
DELETE FROM human_resources.lectures WHERE id = $1 RETURNING id
`

func (q *Queries) RemoveLecture(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, removeLecture, id)
	err := row.Scan(&id)
	return id, err
}

const removeLectureFromCourse = `-- name: RemoveLectureFromCourse :one
DELETE FROM human_resources.courses_lectures WHERE id = $1 RETURNING id
`

func (q *Queries) RemoveLectureFromCourse(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, removeLectureFromCourse, id)
	err := row.Scan(&id)
	return id, err
}

const searchCoursesByTitle = `-- name: SearchCoursesByTitle :many
SELECT id, title, rating, students_count, avatar_url FROM human_resources.courses
WHERE to_tsvector('russian', title) @@ plainto_tsquery('russian', $1)
  AND status = 'READY'
`

type SearchCoursesByTitleRow struct {
	ID            int32
	Title         string
	Rating        *float64
	StudentsCount *int32
	AvatarUrl     *string
}

func (q *Queries) SearchCoursesByTitle(ctx context.Context, title string) ([]*SearchCoursesByTitleRow, error) {
	rows, err := q.db.Query(ctx, searchCoursesByTitle, title)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SearchCoursesByTitleRow
	for rows.Next() {
		var i SearchCoursesByTitleRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Rating,
			&i.StudentsCount,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sendCourseToCheck = `-- name: SendCourseToCheck :one
UPDATE human_resources.courses SET status = 'PENDING', updated_at = now() WHERE id = $1 RETURNING id
`

func (q *Queries) SendCourseToCheck(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, sendCourseToCheck, id)
	err := row.Scan(&id)
	return id, err
}

const updateCourseAvatar = `-- name: UpdateCourseAvatar :one
UPDATE human_resources.courses SET avatar_url = $1 WHERE id = $2 RETURNING avatar_url
`

type UpdateCourseAvatarParams struct {
	AvatarUrl *string
	ID        int32
}

func (q *Queries) UpdateCourseAvatar(ctx context.Context, arg *UpdateCourseAvatarParams) (*string, error) {
	row := q.db.QueryRow(ctx, updateCourseAvatar, arg.AvatarUrl, arg.ID)
	var avatar_url *string
	err := row.Scan(&avatar_url)
	return avatar_url, err
}

const updateCoursePreviewVideo = `-- name: UpdateCoursePreviewVideo :one
UPDATE human_resources.courses SET preview_video_url = $1, updated_at = now() WHERE id = $2 RETURNING preview_video_url
`

type UpdateCoursePreviewVideoParams struct {
	PreviewVideoUrl *string
	ID              int32
}

func (q *Queries) UpdateCoursePreviewVideo(ctx context.Context, arg *UpdateCoursePreviewVideoParams) (*string, error) {
	row := q.db.QueryRow(ctx, updateCoursePreviewVideo, arg.PreviewVideoUrl, arg.ID)
	var preview_video_url *string
	err := row.Scan(&preview_video_url)
	return preview_video_url, err
}

const updateLectureTitle = `-- name: UpdateLectureTitle :one
UPDATE human_resources.lectures SET title = $1 WHERE id = $2 RETURNING id
`

type UpdateLectureTitleParams struct {
	Title string
	ID    int32
}

func (q *Queries) UpdateLectureTitle(ctx context.Context, arg *UpdateLectureTitleParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateLectureTitle, arg.Title, arg.ID)
	var id int32
	err := row.Scan(&id)
	return id, err
}
