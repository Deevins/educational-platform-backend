// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package courses

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addCourseBasicInfo = `-- name: AddCourseBasicInfo :one
UPDATE human_resources.courses SET
        title = $1,
        subtitle = $2,
        description = $3,
        language = $4,
        level = $5,
        category_title = $6,
        updated_at = now()
                        WHERE id = $7 RETURNING id
`

type AddCourseBasicInfoParams struct {
	Title         string
	Subtitle      *string
	Description   string
	Language      *string
	Level         *string
	CategoryTitle string
	ID            int32
}

func (q *Queries) AddCourseBasicInfo(ctx context.Context, arg *AddCourseBasicInfoParams) (int32, error) {
	row := q.db.QueryRow(ctx, addCourseBasicInfo,
		arg.Title,
		arg.Subtitle,
		arg.Description,
		arg.Language,
		arg.Level,
		arg.CategoryTitle,
		arg.ID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const approveCourse = `-- name: ApproveCourse :one
UPDATE human_resources.courses SET status = 'READY', updated_at = now()  WHERE id = $1 RETURNING id
`

func (q *Queries) ApproveCourse(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, approveCourse, id)
	err := row.Scan(&id)
	return id, err
}

const cancelPublishingCourse = `-- name: CancelPublishingCourse :one
UPDATE human_resources.courses SET status = 'DRAFT', updated_at = now() WHERE id = $1 RETURNING id
`

func (q *Queries) CancelPublishingCourse(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, cancelPublishingCourse, id)
	err := row.Scan(&id)
	return id, err
}

const createAnswer = `-- name: CreateAnswer :one
INSERT INTO human_resources.tests_questions_answers (question_id, body, description, is_correct) VALUES ($1, $2, $3, $4) RETURNING id
`

type CreateAnswerParams struct {
	QuestionID  int32
	Body        string
	Description string
	IsCorrect   bool
}

func (q *Queries) CreateAnswer(ctx context.Context, arg *CreateAnswerParams) (int32, error) {
	row := q.db.QueryRow(ctx, createAnswer,
		arg.QuestionID,
		arg.Body,
		arg.Description,
		arg.IsCorrect,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createCourseBase = `-- name: CreateCourseBase :one
INSERT INTO human_resources.courses (
                title,
                type,
                author_id,
                category_title,
                time_planned)
VALUES ($1,
        $2,
        $3,
        $4,
        $5
       ) RETURNING id
`

type CreateCourseBaseParams struct {
	Title         string
	Type          HumanResourcesCourseTypes
	AuthorID      int32
	CategoryTitle string
	TimePlanned   *string
}

func (q *Queries) CreateCourseBase(ctx context.Context, arg *CreateCourseBaseParams) (int32, error) {
	row := q.db.QueryRow(ctx, createCourseBase,
		arg.Title,
		arg.Type,
		arg.AuthorID,
		arg.CategoryTitle,
		arg.TimePlanned,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createLecture = `-- name: CreateLecture :one
INSERT INTO human_resources.lectures (title, description, section_id, serial_number) VALUES ($1, $2, $3, $4) RETURNING id
`

type CreateLectureParams struct {
	Title        string
	Description  string
	SectionID    int32
	SerialNumber int32
}

func (q *Queries) CreateLecture(ctx context.Context, arg *CreateLectureParams) (int32, error) {
	row := q.db.QueryRow(ctx, createLecture,
		arg.Title,
		arg.Description,
		arg.SectionID,
		arg.SerialNumber,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createQuestion = `-- name: CreateQuestion :one
INSERT INTO human_resources.tests_questions (test_id, body) VALUES ($1, $2) RETURNING id
`

type CreateQuestionParams struct {
	TestID int32
	Body   string
}

func (q *Queries) CreateQuestion(ctx context.Context, arg *CreateQuestionParams) (int32, error) {
	row := q.db.QueryRow(ctx, createQuestion, arg.TestID, arg.Body)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createSection = `-- name: CreateSection :one
INSERT INTO human_resources.sections (title, description, course_id, serial_number) VALUES ($1, $2, $3, $4) RETURNING id
`

type CreateSectionParams struct {
	Title        string
	Description  string
	CourseID     int32
	SerialNumber int32
}

func (q *Queries) CreateSection(ctx context.Context, arg *CreateSectionParams) (int32, error) {
	row := q.db.QueryRow(ctx, createSection,
		arg.Title,
		arg.Description,
		arg.CourseID,
		arg.SerialNumber,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createTest = `-- name: CreateTest :one
INSERT INTO human_resources.tests (name,description, section_id, serial_number) VALUES ($1,$2, $3, $4) RETURNING id
`

type CreateTestParams struct {
	Name         string
	Description  string
	SectionID    int32
	SerialNumber int32
}

func (q *Queries) CreateTest(ctx context.Context, arg *CreateTestParams) (int32, error) {
	row := q.db.QueryRow(ctx, createTest,
		arg.Name,
		arg.Description,
		arg.SectionID,
		arg.SerialNumber,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getAllDraftCourses = `-- name: GetAllDraftCourses :many
SELECT
    c.id AS course_id,
    c.title,
    c.description,
    c.lectures_count,
    c.level,
    c.preview_video_url AS course_preview_video_url,
    c.avatar_url AS course_avatar_url,
    c.subtitle,
    c.rating,
    c.students_count,
    c.ratings_count,
    c.lectures_length_interval,
    u.full_name AS instructor_name,
    u.avatar_url AS instructor_avatar_url,
    c.created_at -- Добавляем created_at в селекцию и группировку
FROM
    human_resources.courses c
        JOIN
    human_resources.users u ON c.author_id = u.id
WHERE
    c.status != 'PENDING'
  AND c.status != 'READY'
GROUP BY
    c.id,
    c.title,
    c.description,
    c.level,
    c.lectures_count,
    c.preview_video_url,
    c.avatar_url,
    c.subtitle,
    c.rating,
    c.students_count,
    c.ratings_count,
    c.lectures_length_interval,
    u.full_name,
    u.avatar_url,
    c.created_at -- Указали created_at в секции GROUP BY
ORDER BY
    c.created_at
`

type GetAllDraftCoursesRow struct {
	CourseID               int32
	Title                  string
	Description            string
	LecturesCount          *int32
	Level                  *string
	CoursePreviewVideoUrl  *string
	CourseAvatarUrl        *string
	Subtitle               *string
	Rating                 *float64
	StudentsCount          *int32
	RatingsCount           *int32
	LecturesLengthInterval pgtype.Interval
	InstructorName         string
	InstructorAvatarUrl    *string
	CreatedAt              pgtype.Timestamptz
}

func (q *Queries) GetAllDraftCourses(ctx context.Context) ([]*GetAllDraftCoursesRow, error) {
	rows, err := q.db.Query(ctx, getAllDraftCourses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllDraftCoursesRow
	for rows.Next() {
		var i GetAllDraftCoursesRow
		if err := rows.Scan(
			&i.CourseID,
			&i.Title,
			&i.Description,
			&i.LecturesCount,
			&i.Level,
			&i.CoursePreviewVideoUrl,
			&i.CourseAvatarUrl,
			&i.Subtitle,
			&i.Rating,
			&i.StudentsCount,
			&i.RatingsCount,
			&i.LecturesLengthInterval,
			&i.InstructorName,
			&i.InstructorAvatarUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPendingCourses = `-- name: GetAllPendingCourses :many
SELECT
    c.id AS course_id,
    c.title,
    c.description,
    c.level,
    c.preview_video_url AS course_preview_video_url,
    c.avatar_url AS course_avatar_url,
    c.subtitle,
    c.lectures_count,
    c.rating,
    c.students_count,
    c.ratings_count,
    c.lectures_length_interval,
    u.full_name AS instructor_name,
    u.avatar_url AS instructor_avatar_url,
    c.created_at -- Добавляем created_at в селекцию и группировку
FROM
    human_resources.courses c
        JOIN
    human_resources.users u ON c.author_id = u.id
WHERE
    c.status != 'DRAFT'
  AND c.status != 'READY'
GROUP BY
    c.id,
    c.title,
    c.description,
    c.lectures_count,
    c.level,
    c.preview_video_url,
    c.avatar_url,
    c.subtitle,
    c.rating,
    c.students_count,
    c.ratings_count,
    c.lectures_length_interval,
    u.full_name,
    u.avatar_url,
    c.created_at -- Указали created_at в секции GROUP BY
ORDER BY
    c.created_at
`

type GetAllPendingCoursesRow struct {
	CourseID               int32
	Title                  string
	Description            string
	Level                  *string
	CoursePreviewVideoUrl  *string
	CourseAvatarUrl        *string
	Subtitle               *string
	LecturesCount          *int32
	Rating                 *float64
	StudentsCount          *int32
	RatingsCount           *int32
	LecturesLengthInterval pgtype.Interval
	InstructorName         string
	InstructorAvatarUrl    *string
	CreatedAt              pgtype.Timestamptz
}

func (q *Queries) GetAllPendingCourses(ctx context.Context) ([]*GetAllPendingCoursesRow, error) {
	rows, err := q.db.Query(ctx, getAllPendingCourses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllPendingCoursesRow
	for rows.Next() {
		var i GetAllPendingCoursesRow
		if err := rows.Scan(
			&i.CourseID,
			&i.Title,
			&i.Description,
			&i.Level,
			&i.CoursePreviewVideoUrl,
			&i.CourseAvatarUrl,
			&i.Subtitle,
			&i.LecturesCount,
			&i.Rating,
			&i.StudentsCount,
			&i.RatingsCount,
			&i.LecturesLengthInterval,
			&i.InstructorName,
			&i.InstructorAvatarUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllReadyCourses = `-- name: GetAllReadyCourses :many
SELECT
    c.id AS course_id,
    c.title,
    c.description,
    c.level,
    c.lectures_count,
    c.preview_video_url AS course_preview_video_url,
    c.avatar_url AS course_avatar_url,
    c.subtitle,
    c.rating,
    c.students_count,
    c.ratings_count,
    c.lectures_length_interval,
    u.full_name AS instructor_name,
    u.avatar_url AS instructor_avatar_url,
    c.created_at -- Добавляем created_at в селекцию и группировку
FROM
    human_resources.courses c
        JOIN
    human_resources.users u ON c.author_id = u.id
WHERE
    c.status != 'PENDING'
  AND c.status != 'DRAFT'
GROUP BY
    c.id,
    c.title,
    c.description,
    c.level,
    c.preview_video_url,
    c.avatar_url,
    c.subtitle,
    c.rating,
    c.lectures_count,
    c.students_count,
    c.ratings_count,
    c.lectures_length_interval,
    u.full_name,
    u.avatar_url,
    c.created_at -- Указали created_at в секции GROUP BY
ORDER BY
    c.created_at
`

type GetAllReadyCoursesRow struct {
	CourseID               int32
	Title                  string
	Description            string
	Level                  *string
	LecturesCount          *int32
	CoursePreviewVideoUrl  *string
	CourseAvatarUrl        *string
	Subtitle               *string
	Rating                 *float64
	StudentsCount          *int32
	RatingsCount           *int32
	LecturesLengthInterval pgtype.Interval
	InstructorName         string
	InstructorAvatarUrl    *string
	CreatedAt              pgtype.Timestamptz
}

func (q *Queries) GetAllReadyCourses(ctx context.Context) ([]*GetAllReadyCoursesRow, error) {
	rows, err := q.db.Query(ctx, getAllReadyCourses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllReadyCoursesRow
	for rows.Next() {
		var i GetAllReadyCoursesRow
		if err := rows.Scan(
			&i.CourseID,
			&i.Title,
			&i.Description,
			&i.Level,
			&i.LecturesCount,
			&i.CoursePreviewVideoUrl,
			&i.CourseAvatarUrl,
			&i.Subtitle,
			&i.Rating,
			&i.StudentsCount,
			&i.RatingsCount,
			&i.LecturesLengthInterval,
			&i.InstructorName,
			&i.InstructorAvatarUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourseAvatarByID = `-- name: GetCourseAvatarByID :one
SELECT avatar_url FROM human_resources.courses WHERE id = $1
`

func (q *Queries) GetCourseAvatarByID(ctx context.Context, id int32) (*string, error) {
	row := q.db.QueryRow(ctx, getCourseAvatarByID, id)
	var avatar_url *string
	err := row.Scan(&avatar_url)
	return avatar_url, err
}

const getCourseBasicInfo = `-- name: GetCourseBasicInfo :one
SELECT c.title, c.subtitle, c.description, c.language, c.level, c.category_title FROM human_resources.courses c WHERE id = $1
`

type GetCourseBasicInfoRow struct {
	Title         string
	Subtitle      *string
	Description   string
	Language      *string
	Level         *string
	CategoryTitle string
}

func (q *Queries) GetCourseBasicInfo(ctx context.Context, id int32) (*GetCourseBasicInfoRow, error) {
	row := q.db.QueryRow(ctx, getCourseBasicInfo, id)
	var i GetCourseBasicInfoRow
	err := row.Scan(
		&i.Title,
		&i.Subtitle,
		&i.Description,
		&i.Language,
		&i.Level,
		&i.CategoryTitle,
	)
	return &i, err
}

const getCourseGoals = `-- name: GetCourseGoals :one
SELECT course_goals, requirements, target_audience FROM human_resources.courses WHERE id = $1
`

type GetCourseGoalsRow struct {
	CourseGoals    []string
	Requirements   []string
	TargetAudience []string
}

func (q *Queries) GetCourseGoals(ctx context.Context, id int32) (*GetCourseGoalsRow, error) {
	row := q.db.QueryRow(ctx, getCourseGoals, id)
	var i GetCourseGoalsRow
	err := row.Scan(&i.CourseGoals, &i.Requirements, &i.TargetAudience)
	return &i, err
}

const getCoursePreviewVideoByID = `-- name: GetCoursePreviewVideoByID :one
SELECT preview_video_url FROM human_resources.courses WHERE id = $1
`

func (q *Queries) GetCoursePreviewVideoByID(ctx context.Context, id int32) (*string, error) {
	row := q.db.QueryRow(ctx, getCoursePreviewVideoByID, id)
	var preview_video_url *string
	err := row.Scan(&preview_video_url)
	return preview_video_url, err
}

const getCourseReviewsByCourseID = `-- name: GetCourseReviewsByCourseID :many
SELECT
    cr.rating AS review_rating,
    cr.review AS review_text,
    cr.created_at AS review_created_at,
    ru.full_name AS reviewer_full_name,
    ru.avatar_url AS reviewer_avatar_url
FROM
    human_resources.courses_reviews cr
        JOIN
    human_resources.users ru ON cr.user_id = ru.id
WHERE
    cr.course_id = $1
    ORDER by cr.created_at ASC
`

type GetCourseReviewsByCourseIDRow struct {
	ReviewRating      int32
	ReviewText        string
	ReviewCreatedAt   pgtype.Timestamptz
	ReviewerFullName  string
	ReviewerAvatarUrl *string
}

func (q *Queries) GetCourseReviewsByCourseID(ctx context.Context, id int32) ([]*GetCourseReviewsByCourseIDRow, error) {
	rows, err := q.db.Query(ctx, getCourseReviewsByCourseID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetCourseReviewsByCourseIDRow
	for rows.Next() {
		var i GetCourseReviewsByCourseIDRow
		if err := rows.Scan(
			&i.ReviewRating,
			&i.ReviewText,
			&i.ReviewCreatedAt,
			&i.ReviewerFullName,
			&i.ReviewerAvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourseSectionSerialNumber = `-- name: GetCourseSectionSerialNumber :one
SELECT serial_number FROM human_resources.sections WHERE course_id = $1 ORDER BY serial_number DESC LIMIT 1
`

func (q *Queries) GetCourseSectionSerialNumber(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, getCourseSectionSerialNumber, id)
	var serial_number int32
	err := row.Scan(&serial_number)
	return serial_number, err
}

const getCoursesAvatarsByIDs = `-- name: GetCoursesAvatarsByIDs :many
SELECT id, avatar_url FROM human_resources.courses WHERE id = ANY($1::int[])
`

type GetCoursesAvatarsByIDsRow struct {
	ID        int32
	AvatarUrl *string
}

func (q *Queries) GetCoursesAvatarsByIDs(ctx context.Context, dollar_1 []int32) ([]*GetCoursesAvatarsByIDsRow, error) {
	rows, err := q.db.Query(ctx, getCoursesAvatarsByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetCoursesAvatarsByIDsRow
	for rows.Next() {
		var i GetCoursesAvatarsByIDsRow
		if err := rows.Scan(&i.ID, &i.AvatarUrl); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFullCourseByID = `-- name: GetFullCourseByID :one
SELECT
    c.id AS course_id,
    c.title,
    c.subtitle,
    c.description,
    c.language,
    c.level,
    c.rating,
    c.students_count,
    c.ratings_count,
    c.lectures_count,
    c.lectures_length_interval,
    c.avatar_url AS course_avatar_url,
    c.preview_video_url,
    c.status AS course_status,
    c.created_at AS course_created_at,
    c.course_goals,
    c.requirements,
    c.target_audience,
    c.author_id,
    c.category_title AS category_title,
    u.full_name AS instructor_full_name,
    u.avatar_url AS instructor_avatar_url,
    u.id AS instructor_id
FROM
    human_resources.courses c
    JOIN human_resources.users u ON c.author_id = u.id
WHERE
    c.id = $1
`

type GetFullCourseByIDRow struct {
	CourseID               int32
	Title                  string
	Subtitle               *string
	Description            string
	Language               *string
	Level                  *string
	Rating                 *float64
	StudentsCount          *int32
	RatingsCount           *int32
	LecturesCount          *int32
	LecturesLengthInterval pgtype.Interval
	CourseAvatarUrl        *string
	PreviewVideoUrl        *string
	CourseStatus           HumanResourcesCourseStatuses
	CourseCreatedAt        pgtype.Timestamptz
	CourseGoals            []string
	Requirements           []string
	TargetAudience         []string
	AuthorID               int32
	CategoryTitle          string
	InstructorFullName     string
	InstructorAvatarUrl    *string
	InstructorID           int32
}

func (q *Queries) GetFullCourseByID(ctx context.Context, id int32) (*GetFullCourseByIDRow, error) {
	row := q.db.QueryRow(ctx, getFullCourseByID, id)
	var i GetFullCourseByIDRow
	err := row.Scan(
		&i.CourseID,
		&i.Title,
		&i.Subtitle,
		&i.Description,
		&i.Language,
		&i.Level,
		&i.Rating,
		&i.StudentsCount,
		&i.RatingsCount,
		&i.LecturesCount,
		&i.LecturesLengthInterval,
		&i.CourseAvatarUrl,
		&i.PreviewVideoUrl,
		&i.CourseStatus,
		&i.CourseCreatedAt,
		&i.CourseGoals,
		&i.Requirements,
		&i.TargetAudience,
		&i.AuthorID,
		&i.CategoryTitle,
		&i.InstructorFullName,
		&i.InstructorAvatarUrl,
		&i.InstructorID,
	)
	return &i, err
}

const getFullCourseInfoWithInstructorByCourseID = `-- name: GetFullCourseInfoWithInstructorByCourseID :one
SELECT
    c.id AS course_id,
    c.title,
    c.subtitle,
    c.description,
    c.language,
    c.level,
    u.description AS instructor_description,
    c.rating,
    c.students_count,
    c.ratings_count,
    c.lectures_count,
    c.lectures_length_interval,
    c.avatar_url AS course_avatar_url,
    c.preview_video_url,
    c.status AS course_status,
    c.created_at AS course_created_at,
    c.course_goals,
    c.requirements,
    c.target_audience,
    c.author_id,
    c.category_title AS category_title,
    u.full_name AS instructor_full_name,
    (SELECT COUNT(*) FROM human_resources.courses WHERE author_id = u.id) AS instructor_courses_count,
    (SELECT SUM(students_count) FROM human_resources.courses WHERE author_id = u.id) AS instructor_students_count,
    (SELECT COUNT(*) FROM human_resources.courses_reviews cr
     JOIN human_resources.courses cc ON cr.course_id = cc.id
     WHERE cc.author_id = u.id) AS total_reviews_count,
    u.instructor_rating,
    u.avatar_url AS instructor_avatar_url,
    u.id AS instructor_id
FROM
    human_resources.courses c
    JOIN human_resources.users u ON c.author_id = u.id
WHERE
    c.id = $1
`

type GetFullCourseInfoWithInstructorByCourseIDRow struct {
	CourseID                int32
	Title                   string
	Subtitle                *string
	Description             string
	Language                *string
	Level                   *string
	InstructorDescription   *string
	Rating                  *float64
	StudentsCount           *int32
	RatingsCount            *int32
	LecturesCount           *int32
	LecturesLengthInterval  pgtype.Interval
	CourseAvatarUrl         *string
	PreviewVideoUrl         *string
	CourseStatus            HumanResourcesCourseStatuses
	CourseCreatedAt         pgtype.Timestamptz
	CourseGoals             []string
	Requirements            []string
	TargetAudience          []string
	AuthorID                int32
	CategoryTitle           string
	InstructorFullName      string
	InstructorCoursesCount  int64
	InstructorStudentsCount int64
	TotalReviewsCount       int64
	InstructorRating        float64
	InstructorAvatarUrl     *string
	InstructorID            int32
}

func (q *Queries) GetFullCourseInfoWithInstructorByCourseID(ctx context.Context, id int32) (*GetFullCourseInfoWithInstructorByCourseIDRow, error) {
	row := q.db.QueryRow(ctx, getFullCourseInfoWithInstructorByCourseID, id)
	var i GetFullCourseInfoWithInstructorByCourseIDRow
	err := row.Scan(
		&i.CourseID,
		&i.Title,
		&i.Subtitle,
		&i.Description,
		&i.Language,
		&i.Level,
		&i.InstructorDescription,
		&i.Rating,
		&i.StudentsCount,
		&i.RatingsCount,
		&i.LecturesCount,
		&i.LecturesLengthInterval,
		&i.CourseAvatarUrl,
		&i.PreviewVideoUrl,
		&i.CourseStatus,
		&i.CourseCreatedAt,
		&i.CourseGoals,
		&i.Requirements,
		&i.TargetAudience,
		&i.AuthorID,
		&i.CategoryTitle,
		&i.InstructorFullName,
		&i.InstructorCoursesCount,
		&i.InstructorStudentsCount,
		&i.TotalReviewsCount,
		&i.InstructorRating,
		&i.InstructorAvatarUrl,
		&i.InstructorID,
	)
	return &i, err
}

const getInstructorCourses = `-- name: GetInstructorCourses :many
SELECT c.id, c.avatar_url, c.title, c.ratings_count, c.rating FROM human_resources.courses c WHERE author_id = $1 ORDER BY created_at DESC
`

type GetInstructorCoursesRow struct {
	ID           int32
	AvatarUrl    *string
	Title        string
	RatingsCount *int32
	Rating       *float64
}

func (q *Queries) GetInstructorCourses(ctx context.Context, authorID int32) ([]*GetInstructorCoursesRow, error) {
	rows, err := q.db.Query(ctx, getInstructorCourses, authorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetInstructorCoursesRow
	for rows.Next() {
		var i GetInstructorCoursesRow
		if err := rows.Scan(
			&i.ID,
			&i.AvatarUrl,
			&i.Title,
			&i.RatingsCount,
			&i.Rating,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestUserTestAttempt = `-- name: GetLatestUserTestAttempt :one
SELECT attempt_number FROM human_resources.tests_users_attempts WHERE user_id = $1 AND test_id = $2 ORDER BY created_at DESC LIMIT 1
`

type GetLatestUserTestAttemptParams struct {
	UserID int32
	TestID int32
}

func (q *Queries) GetLatestUserTestAttempt(ctx context.Context, arg *GetLatestUserTestAttemptParams) (int32, error) {
	row := q.db.QueryRow(ctx, getLatestUserTestAttempt, arg.UserID, arg.TestID)
	var attempt_number int32
	err := row.Scan(&attempt_number)
	return attempt_number, err
}

const getLectureByID = `-- name: GetLectureByID :one
SELECT id, title, description, video_url, lecture_video_length FROM human_resources.lectures WHERE id = $1
`

type GetLectureByIDRow struct {
	ID                 int32
	Title              string
	Description        string
	VideoUrl           string
	LectureVideoLength pgtype.Interval
}

func (q *Queries) GetLectureByID(ctx context.Context, id int32) (*GetLectureByIDRow, error) {
	row := q.db.QueryRow(ctx, getLectureByID, id)
	var i GetLectureByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.VideoUrl,
		&i.LectureVideoLength,
	)
	return &i, err
}

const getLectureSerialNumber = `-- name: GetLectureSerialNumber :one
SELECT serial_number FROM human_resources.lectures WHERE section_id = $1 ORDER BY serial_number DESC LIMIT 1
`

func (q *Queries) GetLectureSerialNumber(ctx context.Context, sectionID int32) (int32, error) {
	row := q.db.QueryRow(ctx, getLectureSerialNumber, sectionID)
	var serial_number int32
	err := row.Scan(&serial_number)
	return serial_number, err
}

const getLecturesByCourseID = `-- name: GetLecturesByCourseID :many
SELECT
    s.id AS section_id,
    l.id AS lecture_id,
    l.title AS lecture_title,
    l.description AS lecture_description,
    l.video_url AS lecture_video_url,
    l.serial_number AS lecture_serial_number,
    r.id AS resource_id,
    r.title AS resource_title,
    r.extension AS resource_extension,
    r.resource_url AS resource_url
FROM
    human_resources.sections s
        LEFT JOIN human_resources.lectures l ON s.id = l.section_id
        LEFT JOIN human_resources.lectures_resources r ON l.id = r.lecture_id
WHERE
    s.course_id = $1
  AND l.id IS NOT NULL
`

type GetLecturesByCourseIDRow struct {
	SectionID           int32
	LectureID           *int32
	LectureTitle        *string
	LectureDescription  *string
	LectureVideoUrl     *string
	LectureSerialNumber *int32
	ResourceID          *int32
	ResourceTitle       *string
	ResourceExtension   *string
	ResourceUrl         *string
}

func (q *Queries) GetLecturesByCourseID(ctx context.Context, courseID int32) ([]*GetLecturesByCourseIDRow, error) {
	rows, err := q.db.Query(ctx, getLecturesByCourseID, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetLecturesByCourseIDRow
	for rows.Next() {
		var i GetLecturesByCourseIDRow
		if err := rows.Scan(
			&i.SectionID,
			&i.LectureID,
			&i.LectureTitle,
			&i.LectureDescription,
			&i.LectureVideoUrl,
			&i.LectureSerialNumber,
			&i.ResourceID,
			&i.ResourceTitle,
			&i.ResourceExtension,
			&i.ResourceUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSectionsByCourseID = `-- name: GetSectionsByCourseID :many
SELECT
    id AS section_id,
    title AS section_title,
    description AS section_description,
    serial_number AS section_serial_number,
    course_id
FROM
    human_resources.sections
WHERE
    course_id = $1
`

type GetSectionsByCourseIDRow struct {
	SectionID           int32
	SectionTitle        string
	SectionDescription  string
	SectionSerialNumber int32
	CourseID            int32
}

func (q *Queries) GetSectionsByCourseID(ctx context.Context, courseID int32) ([]*GetSectionsByCourseIDRow, error) {
	rows, err := q.db.Query(ctx, getSectionsByCourseID, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetSectionsByCourseIDRow
	for rows.Next() {
		var i GetSectionsByCourseIDRow
		if err := rows.Scan(
			&i.SectionID,
			&i.SectionTitle,
			&i.SectionDescription,
			&i.SectionSerialNumber,
			&i.CourseID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSectionsWithLecturesAndTestsByCourseID = `-- name: GetSectionsWithLecturesAndTestsByCourseID :many
WITH recursive_section AS (
    SELECT
        s.id AS section_id,
        s.title AS section_title,
        s.description AS section_description,
        s.course_id AS course_id,
        l.id AS lecture_id,
        l.title AS lecture_title,
        l.description AS lecture_description,
        l.video_url AS lecture_video_url,
        l.serial_number AS lecture_serial_number,
        t.id AS test_id,
        t.name AS test_name,
        q.id AS question_id,
        q.body AS question_body,
        a.id AS answer_id,
        a.body AS answer_body,
        a.is_correct AS answer_is_correct,
        a.description AS answer_description,
        r.id AS resource_id,
        r.title AS resource_title,
        r.extension AS resource_extension,
        r.resource_url AS resource_url
    FROM
        human_resources.sections s
            LEFT JOIN
        human_resources.lectures l ON s.id = l.section_id
            LEFT JOIN
        human_resources.lectures_resources r ON l.id = r.lecture_id
            LEFT JOIN
        human_resources.tests t ON s.id = t.section_id
            LEFT JOIN
        human_resources.tests_questions q ON t.id = q.test_id
            LEFT JOIN
        human_resources.tests_questions_answers a ON q.id = a.question_id
    WHERE
        s.course_id = $1
)
SELECT
    section_id,
    section_title,
    section_description,
    lecture_id,
    lecture_title,
    lecture_description,
    lecture_video_url,
    lecture_serial_number,
    resource_id,
    resource_title,
    resource_extension,
    resource_url,
    test_id,
    test_name,
    question_id,
    question_body,
    answer_id,
    answer_body,
    answer_is_correct,
    answer_description
FROM
    recursive_section
ORDER BY
    section_id,
    lecture_id,
    resource_id,
    test_id,
    question_id,
    answer_id
`

type GetSectionsWithLecturesAndTestsByCourseIDRow struct {
	SectionID           int32
	SectionTitle        string
	SectionDescription  string
	LectureID           *int32
	LectureTitle        *string
	LectureDescription  *string
	LectureVideoUrl     *string
	LectureSerialNumber *int32
	ResourceID          *int32
	ResourceTitle       *string
	ResourceExtension   *string
	ResourceUrl         *string
	TestID              *int32
	TestName            *string
	QuestionID          *int32
	QuestionBody        *string
	AnswerID            *int32
	AnswerBody          *string
	AnswerIsCorrect     *bool
	AnswerDescription   *string
}

func (q *Queries) GetSectionsWithLecturesAndTestsByCourseID(ctx context.Context, courseID int32) ([]*GetSectionsWithLecturesAndTestsByCourseIDRow, error) {
	rows, err := q.db.Query(ctx, getSectionsWithLecturesAndTestsByCourseID, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetSectionsWithLecturesAndTestsByCourseIDRow
	for rows.Next() {
		var i GetSectionsWithLecturesAndTestsByCourseIDRow
		if err := rows.Scan(
			&i.SectionID,
			&i.SectionTitle,
			&i.SectionDescription,
			&i.LectureID,
			&i.LectureTitle,
			&i.LectureDescription,
			&i.LectureVideoUrl,
			&i.LectureSerialNumber,
			&i.ResourceID,
			&i.ResourceTitle,
			&i.ResourceExtension,
			&i.ResourceUrl,
			&i.TestID,
			&i.TestName,
			&i.QuestionID,
			&i.QuestionBody,
			&i.AnswerID,
			&i.AnswerBody,
			&i.AnswerIsCorrect,
			&i.AnswerDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestSerialNumber = `-- name: GetTestSerialNumber :one
SELECT serial_number FROM human_resources.tests WHERE section_id = $1 ORDER BY serial_number DESC LIMIT 1
`

func (q *Queries) GetTestSerialNumber(ctx context.Context, sectionID int32) (int32, error) {
	row := q.db.QueryRow(ctx, getTestSerialNumber, sectionID)
	var serial_number int32
	err := row.Scan(&serial_number)
	return serial_number, err
}

const getTestsByCourseID = `-- name: GetTestsByCourseID :many
SELECT
    s.id AS section_id,
    t.id AS test_id,
    t.name AS test_name,
    t.description AS test_description,
    t.serial_number AS test_serial_number,
    q.id AS question_id,
    q.body AS question_body,
    a.id AS answer_id,
    a.body AS answer_body,
    a.is_correct AS answer_is_correct,
    a.description AS answer_description
FROM
    human_resources.sections s
        LEFT JOIN human_resources.tests t ON s.id = t.section_id
        LEFT JOIN human_resources.tests_questions q ON t.id = q.test_id
        LEFT JOIN human_resources.tests_questions_answers a ON q.id = a.question_id
WHERE
    s.course_id = $1
  AND t.id IS NOT NULL
`

type GetTestsByCourseIDRow struct {
	SectionID         int32
	TestID            *int32
	TestName          *string
	TestDescription   *string
	TestSerialNumber  *int32
	QuestionID        *int32
	QuestionBody      *string
	AnswerID          *int32
	AnswerBody        *string
	AnswerIsCorrect   *bool
	AnswerDescription *string
}

func (q *Queries) GetTestsByCourseID(ctx context.Context, courseID int32) ([]*GetTestsByCourseIDRow, error) {
	rows, err := q.db.Query(ctx, getTestsByCourseID, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTestsByCourseIDRow
	for rows.Next() {
		var i GetTestsByCourseIDRow
		if err := rows.Scan(
			&i.SectionID,
			&i.TestID,
			&i.TestName,
			&i.TestDescription,
			&i.TestSerialNumber,
			&i.QuestionID,
			&i.QuestionBody,
			&i.AnswerID,
			&i.AnswerBody,
			&i.AnswerIsCorrect,
			&i.AnswerDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCourses = `-- name: GetUserCourses :many
SELECT c.id, c.title, c.description,
       c.avatar_url, c.subtitle,
       c.rating, c.students_count,
       c.ratings_count,
       c.lectures_length_interval FROM human_resources.courses c
                    INNER JOIN human_resources.courses_attendants uc ON c.id = uc.course_id
WHERE uc.user_id = $1
  AND c.status != 'DRAFT'
  AND c.status != 'PENDING'
ORDER BY
    c.created_at
`

type GetUserCoursesRow struct {
	ID                     int32
	Title                  string
	Description            string
	AvatarUrl              *string
	Subtitle               *string
	Rating                 *float64
	StudentsCount          *int32
	RatingsCount           *int32
	LecturesLengthInterval pgtype.Interval
}

func (q *Queries) GetUserCourses(ctx context.Context, userID int32) ([]*GetUserCoursesRow, error) {
	rows, err := q.db.Query(ctx, getUserCourses, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUserCoursesRow
	for rows.Next() {
		var i GetUserCoursesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.AvatarUrl,
			&i.Subtitle,
			&i.Rating,
			&i.StudentsCount,
			&i.RatingsCount,
			&i.LecturesLengthInterval,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectCourse = `-- name: RejectCourse :one
UPDATE human_resources.courses SET status = 'DRAFT', updated_at = now()  WHERE id = $1 RETURNING id
`

func (q *Queries) RejectCourse(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, rejectCourse, id)
	err := row.Scan(&id)
	return id, err
}

const removeAnswer = `-- name: RemoveAnswer :one
DELETE FROM human_resources.tests_questions_answers WHERE id = $1 RETURNING id
`

func (q *Queries) RemoveAnswer(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, removeAnswer, id)
	err := row.Scan(&id)
	return id, err
}

const removeCourse = `-- name: RemoveCourse :one
DELETE FROM human_resources.courses WHERE id = $1 RETURNING id
`

func (q *Queries) RemoveCourse(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, removeCourse, id)
	err := row.Scan(&id)
	return id, err
}

const removeLecture = `-- name: RemoveLecture :one
DELETE FROM human_resources.lectures WHERE id = $1  RETURNING id
`

func (q *Queries) RemoveLecture(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, removeLecture, id)
	err := row.Scan(&id)
	return id, err
}

const removeQuestion = `-- name: RemoveQuestion :one
DELETE FROM human_resources.tests_questions WHERE id = $1 RETURNING id
`

func (q *Queries) RemoveQuestion(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, removeQuestion, id)
	err := row.Scan(&id)
	return id, err
}

const removeQuestionAnswers = `-- name: RemoveQuestionAnswers :many
DELETE FROM human_resources.tests_questions_answers WHERE question_id = $1 RETURNING id
`

func (q *Queries) RemoveQuestionAnswers(ctx context.Context, questionID int32) ([]int32, error) {
	rows, err := q.db.Query(ctx, removeQuestionAnswers, questionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeSection = `-- name: RemoveSection :one
DELETE FROM human_resources.sections WHERE id = $1 RETURNING id
`

func (q *Queries) RemoveSection(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, removeSection, id)
	err := row.Scan(&id)
	return id, err
}

const removeTest = `-- name: RemoveTest :one
DELETE FROM human_resources.tests WHERE id = $1 RETURNING id
`

func (q *Queries) RemoveTest(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, removeTest, id)
	err := row.Scan(&id)
	return id, err
}

const searchCoursesByTitle = `-- name: SearchCoursesByTitle :many
SELECT id, title, rating, students_count, avatar_url FROM human_resources.courses
WHERE to_tsvector('russian', title) @@ plainto_tsquery('russian', $1)
  AND status = 'READY'
`

type SearchCoursesByTitleRow struct {
	ID            int32
	Title         string
	Rating        *float64
	StudentsCount *int32
	AvatarUrl     *string
}

func (q *Queries) SearchCoursesByTitle(ctx context.Context, title string) ([]*SearchCoursesByTitleRow, error) {
	rows, err := q.db.Query(ctx, searchCoursesByTitle, title)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SearchCoursesByTitleRow
	for rows.Next() {
		var i SearchCoursesByTitleRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Rating,
			&i.StudentsCount,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchInstructorCoursesByTitle = `-- name: SearchInstructorCoursesByTitle :many
SELECT c.id, c.avatar_url, c.title, c.status, c.title, c.ratings_count, c.rating FROM human_resources.courses c
WHERE to_tsvector('russian', c.title) @@ plainto_tsquery('russian', $1)
  AND author_id = $2
`

type SearchInstructorCoursesByTitleParams struct {
	Title    string
	AuthorID int32
}

type SearchInstructorCoursesByTitleRow struct {
	ID           int32
	AvatarUrl    *string
	Title        string
	Status       HumanResourcesCourseStatuses
	Title_2      string
	RatingsCount *int32
	Rating       *float64
}

func (q *Queries) SearchInstructorCoursesByTitle(ctx context.Context, arg *SearchInstructorCoursesByTitleParams) ([]*SearchInstructorCoursesByTitleRow, error) {
	rows, err := q.db.Query(ctx, searchInstructorCoursesByTitle, arg.Title, arg.AuthorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SearchInstructorCoursesByTitleRow
	for rows.Next() {
		var i SearchInstructorCoursesByTitleRow
		if err := rows.Scan(
			&i.ID,
			&i.AvatarUrl,
			&i.Title,
			&i.Status,
			&i.Title_2,
			&i.RatingsCount,
			&i.Rating,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sendCourseToCheck = `-- name: SendCourseToCheck :one
UPDATE human_resources.courses SET status = 'PENDING', updated_at = now() WHERE id = $1 RETURNING id
`

func (q *Queries) SendCourseToCheck(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, sendCourseToCheck, id)
	err := row.Scan(&id)
	return id, err
}

const submitTestResult = `-- name: SubmitTestResult :one
INSERT INTO human_resources.tests_users_attempts (user_id, test_id, attempt_number, correct_answers_count, total_questions_count) VALUES ($1, $2, $3, $4, $5) RETURNING id
`

type SubmitTestResultParams struct {
	UserID              int32
	TestID              int32
	AttemptNumber       int32
	CorrectAnswersCount int32
	TotalQuestionsCount int32
}

func (q *Queries) SubmitTestResult(ctx context.Context, arg *SubmitTestResultParams) (int32, error) {
	row := q.db.QueryRow(ctx, submitTestResult,
		arg.UserID,
		arg.TestID,
		arg.AttemptNumber,
		arg.CorrectAnswersCount,
		arg.TotalQuestionsCount,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateAnswer = `-- name: UpdateAnswer :one
UPDATE human_resources.tests_questions_answers SET body = $1, description = $2, is_correct = $3 WHERE id = $4 RETURNING id
`

type UpdateAnswerParams struct {
	Body        string
	Description string
	IsCorrect   bool
	ID          int32
}

func (q *Queries) UpdateAnswer(ctx context.Context, arg *UpdateAnswerParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateAnswer,
		arg.Body,
		arg.Description,
		arg.IsCorrect,
		arg.ID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateCourseAvatar = `-- name: UpdateCourseAvatar :one
UPDATE human_resources.courses SET avatar_url = $1 WHERE id = $2 RETURNING avatar_url
`

type UpdateCourseAvatarParams struct {
	AvatarUrl *string
	ID        int32
}

func (q *Queries) UpdateCourseAvatar(ctx context.Context, arg *UpdateCourseAvatarParams) (*string, error) {
	row := q.db.QueryRow(ctx, updateCourseAvatar, arg.AvatarUrl, arg.ID)
	var avatar_url *string
	err := row.Scan(&avatar_url)
	return avatar_url, err
}

const updateCourseGoals = `-- name: UpdateCourseGoals :one
UPDATE human_resources.courses SET course_goals = $1, requirements = $2, target_audience = $3, updated_at = now() WHERE id = $4 RETURNING id
`

type UpdateCourseGoalsParams struct {
	CourseGoals    []string
	Requirements   []string
	TargetAudience []string
	ID             int32
}

func (q *Queries) UpdateCourseGoals(ctx context.Context, arg *UpdateCourseGoalsParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateCourseGoals,
		arg.CourseGoals,
		arg.Requirements,
		arg.TargetAudience,
		arg.ID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateCoursePreviewVideo = `-- name: UpdateCoursePreviewVideo :one
UPDATE human_resources.courses SET preview_video_url = $1, updated_at = now() WHERE id = $2 RETURNING preview_video_url
`

type UpdateCoursePreviewVideoParams struct {
	PreviewVideoUrl *string
	ID              int32
}

func (q *Queries) UpdateCoursePreviewVideo(ctx context.Context, arg *UpdateCoursePreviewVideoParams) (*string, error) {
	row := q.db.QueryRow(ctx, updateCoursePreviewVideo, arg.PreviewVideoUrl, arg.ID)
	var preview_video_url *string
	err := row.Scan(&preview_video_url)
	return preview_video_url, err
}

const updateLectureTitle = `-- name: UpdateLectureTitle :one
UPDATE human_resources.lectures SET title = $1 WHERE id = $2 RETURNING id
`

type UpdateLectureTitleParams struct {
	Title string
	ID    int32
}

func (q *Queries) UpdateLectureTitle(ctx context.Context, arg *UpdateLectureTitleParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateLectureTitle, arg.Title, arg.ID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateLectureVideoAddedInfo = `-- name: UpdateLectureVideoAddedInfo :one
UPDATE human_resources.lectures SET lecture_video_length = $1 WHERE id = $2 RETURNING id
`

type UpdateLectureVideoAddedInfoParams struct {
	LectureVideoLength pgtype.Interval
	ID                 int32
}

func (q *Queries) UpdateLectureVideoAddedInfo(ctx context.Context, arg *UpdateLectureVideoAddedInfoParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateLectureVideoAddedInfo, arg.LectureVideoLength, arg.ID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateLectureVideoUrl = `-- name: UpdateLectureVideoUrl :one
UPDATE human_resources.lectures SET video_url = $1 WHERE id = $2 RETURNING id
`

type UpdateLectureVideoUrlParams struct {
	VideoUrl string
	ID       int32
}

func (q *Queries) UpdateLectureVideoUrl(ctx context.Context, arg *UpdateLectureVideoUrlParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateLectureVideoUrl, arg.VideoUrl, arg.ID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateLecturesInfo = `-- name: UpdateLecturesInfo :one
UPDATE human_resources.courses
SET lectures_count = lectures_count + $1,
    lectures_length_interval = lectures_length_interval + $2
WHERE id = $3 RETURNING id
`

type UpdateLecturesInfoParams struct {
	LecturesCount          *int32
	LecturesLengthInterval pgtype.Interval
	ID                     int32
}

func (q *Queries) UpdateLecturesInfo(ctx context.Context, arg *UpdateLecturesInfoParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateLecturesInfo, arg.LecturesCount, arg.LecturesLengthInterval, arg.ID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateQuestion = `-- name: UpdateQuestion :one
UPDATE human_resources.tests_questions SET body = $1 WHERE id = $2 RETURNING id
`

type UpdateQuestionParams struct {
	Body string
	ID   int32
}

func (q *Queries) UpdateQuestion(ctx context.Context, arg *UpdateQuestionParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateQuestion, arg.Body, arg.ID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateQuestionAnswers = `-- name: UpdateQuestionAnswers :many
UPDATE human_resources.tests_questions_answers SET body = $1, description = $2, is_correct = $3 WHERE question_id = $4 RETURNING question_id
`

type UpdateQuestionAnswersParams struct {
	Body        string
	Description string
	IsCorrect   bool
	QuestionID  int32
}

func (q *Queries) UpdateQuestionAnswers(ctx context.Context, arg *UpdateQuestionAnswersParams) ([]int32, error) {
	rows, err := q.db.Query(ctx, updateQuestionAnswers,
		arg.Body,
		arg.Description,
		arg.IsCorrect,
		arg.QuestionID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var question_id int32
		if err := rows.Scan(&question_id); err != nil {
			return nil, err
		}
		items = append(items, question_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSectionTitle = `-- name: UpdateSectionTitle :one
UPDATE human_resources.sections SET title = $1 WHERE id = $2 RETURNING id
`

type UpdateSectionTitleParams struct {
	Title string
	ID    int32
}

func (q *Queries) UpdateSectionTitle(ctx context.Context, arg *UpdateSectionTitleParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateSectionTitle, arg.Title, arg.ID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateTestTitle = `-- name: UpdateTestTitle :one
UPDATE human_resources.tests SET name = $1 WHERE  id = $2 RETURNING id
`

type UpdateTestTitleParams struct {
	Name string
	ID   int32
}

func (q *Queries) UpdateTestTitle(ctx context.Context, arg *UpdateTestTitleParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateTestTitle, arg.Name, arg.ID)
	var id int32
	err := row.Scan(&id)
	return id, err
}
